#ifndef __TRACE_HPP__
#define __TRACE_HPP__

#include <iostream>
#include <string>
#include <fstream>
#include <unordered_map>
#include <vector>

#include "json.hpp"

namespace oxton {

enum event_type
{
    EV_BEGIN_SEND = 0,
    EV_END_SEND,
    EV_BEGIN_RECV,
    EV_END_RECV
};

class phase
{
public:
    phase(int n_procs, int phase_idx) : n_events_(0)
    {
        tx_bytes_.resize(n_procs);
        rx_bytes_.resize(n_procs);
        tx_messages_.resize(n_procs);
        rx_messages_.resize(n_procs);
    }

    void feed_event(event_type type, int peer, int len, int tag)
    {
        n_events_++;

        switch (type) {
        case EV_BEGIN_SEND:
            tx_bytes_[peer] += len;
            tx_messages_[peer]++;
            tx_message_sizes_[len]++;
            break;
        case EV_BEGIN_RECV:
            rx_bytes_[peer] += len;
            rx_messages_[peer]++;
            rx_message_sizes_[len]++;
            break;
        default:
            break;
        }
    }

    int n_events_;

    std::vector<uint64_t> tx_bytes_;
    std::vector<uint64_t> rx_bytes_;
    std::vector<uint64_t> tx_messages_;
    std::vector<uint64_t> rx_messages_;
    std::unordered_map<int, uint64_t> tx_message_sizes_;
    std::unordered_map<int, uint64_t> rx_message_sizes_;
};

inline void to_json(nlohmann::json& j, const phase& p) {
    j["n_events"] = p.n_events_;

    j["tx_bytes"] = p.tx_bytes_;
    j["rx_bytes"] = p.rx_bytes_;
    j["tx_messages"] = p.tx_messages_;
    j["rx_messages"] = p.rx_messages_;

    j["tx_message_sizes"] = nlohmann::json::array();
    for (const auto& kv : p.tx_message_sizes_) {
        j["tx_message_sizes"].push_back({
            {"message_size", kv.first},
            {"frequency", kv.second},
        });
    }

    j["rx_message_sizes"] = nlohmann::json::array();
    for (const auto& kv : p.rx_message_sizes_) {
        j["rx_message_sizes"].push_back({
            {"message_size", kv.first},
            {"frequency", kv.second},
        });
    }
}

class trace
{
public:
    trace(int n_procs, int rank, const char *processor_name)
        : phase_idx_(0)
    {
        n_procs_ = n_procs;
        rank_ = rank;
        processor_name_ = std::string(processor_name);

        phases_.push_back(phase(n_procs_, 0));
    }

    void set_phase(int idx)
    {
        phase_idx_ = idx;
    }

    void feed_event(event_type type, int peer, int len, int tag)
    {
        phases_[0].feed_event(type, peer, len, tag);

        if (phase_idx_ == 0) {
            return;
        }

        if (phase_idx_ >= phases_.size()) {
            for (int i = phases_.size(); i <= phase_idx_; ++i) {
                phases_.push_back(phase(n_procs_, i));
            }
        }
        phases_[phase_idx_].feed_event(type, peer, len, tag);
    }

    void write_result(const std::string& path)
    {
        nlohmann::json j;

        // Meta data
        j["processor_name"] = processor_name_;
        j["rank"] = rank_;
        j["n_procs"] = n_procs_;
        j["description"] = "Generated by Oxton v0.2.0";
        j["phases"] = phases_;
        j["n_phases"] = phases_.size();

        std::ofstream ofs(path);
        ofs << std::setw(4) << j << std::endl;
    }

    std::string processor_name_;
    int rank_;
    int n_procs_;
    std::string description_;

    int phase_idx_;
    std::vector<phase> phases_;
};

}

#endif
